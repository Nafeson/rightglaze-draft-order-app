import express from "express";
import crypto from "crypto";

const app = express();
app.use(express.json({ limit: "1mb" }));

/**
* ENV you must set:
* - SHOPIFY_SHOP: yourshop.myshopify.com
* - SHOPIFY_ADMIN_TOKEN: Admin API access token from the custom app
* - SHOPIFY_API_SECRET: App secret key (used to validate App Proxy signature)
* - SHOPIFY_API_VERSION: e.g. 2025-10 (or current stable)
* - PRESENTMENT_CURRENCY: GBP
* - PORT: (Render sets this automatically)
*/
const {
SHOPIFY_SHOP,
SHOPIFY_ADMIN_TOKEN,
SHOPIFY_API_SECRET,
SHOPIFY_API_VERSION = "2025-10",
PRESENTMENT_CURRENCY = "GBP",
PORT = 3000
} = process.env;

if (!SHOPIFY_SHOP || !SHOPIFY_ADMIN_TOKEN || !SHOPIFY_API_SECRET) {
console.error("Missing env. Need SHOPIFY_SHOP, SHOPIFY_ADMIN_TOKEN, SHOPIFY_API_SECRET.");
process.exit(1);
}

/* =========================
PRICING (INC VAT)
- Mirrors your current Stage 1 logic
========================= */

const PRICING = {
BASE_RATE: 150, // £/m²
MIN_PRICE: 72.07, // minimum charge
MM_FACTOR: 0.002 // £ per (w+h) mm
};

function calcUnitPriceIncVat(unit) {
const { outerGlass, innerGlass, selfCleaning, widthMm, heightMm } = unit;

if (!Number.isFinite(widthMm) || !Number.isFinite(heightMm) || widthMm <= 0 || heightMm <= 0) return 0;

// Stage 1 pricing only for this config:
if (outerGlass === "4mm Clear" && innerGlass === "4mm Clear" && selfCleaning === "No") {
const areaM2 = (widthMm * heightMm) / 1_000_000;
const areaCost = areaM2 * PRICING.BASE_RATE;
const mmAdj = (widthMm + heightMm) * PRICING.MM_FACTOR;
return Math.max(PRICING.MIN_PRICE, areaCost) + mmAdj;
}

// Unpriced until you add more stages:
return 0;
}

/* =========================
RULES (mirror calculator)
========================= */

function clampDims(w, h) {
const min = 150, maxW = 2000, maxH = 3000;
const cw = Math.min(maxW, Math.max(min, w));
const ch = Math.min(maxH, Math.max(min, h));
return { w: cw, h: ch };
}

function applyAreaRule(unit) {
const AREA_LIMIT = 2.5;
const areaM2 = (unit.widthMm * unit.heightMm) / 1_000_000;

if (areaM2 >= AREA_LIMIT && unit.outerGlass === "4mm Clear" && unit.innerGlass === "4mm Clear") {
return { ...unit, outerGlass: "6mm Clear", innerGlass: "6mm Clear", _areaUpgradeApplied: true };
}
return { ...unit, _areaUpgradeApplied: false };
}

function normalizeUnit(raw) {
const w = Number(raw.widthMm);
const h = Number(raw.heightMm);
const { w: cw, h: ch } = clampDims(w, h);

const unit = {
qty: Number(raw.qty) || 1,
outerGlass: String(raw.outerGlass || ""),
innerGlass: String(raw.innerGlass || ""),
cavityWidth: String(raw.cavityWidth || ""),
selfCleaning: String(raw.selfCleaning || "No"),
spacer: String(raw.spacer || ""),
widthMm: cw,
heightMm: ch
};

unit.qty = Math.min(10, Math.max(1, unit.qty));
unit.toughened = "Yes"; // forced yes-only

return applyAreaRule(unit);
}

/* =========================
APP PROXY SIGNATURE VALIDATION
Shopify app proxy provides `signature` param and expects:
- remove signature
- split on '&', parse
- sort, concatenate (no delimiter)
- HMAC-SHA256 hex with shared secret
========================= */

function timingSafeEqualHex(a, b) {
const ab = Buffer.from(a, "hex");
const bb = Buffer.from(b, "hex");
if (ab.length !== bb.length) return false;
return crypto.timingSafeEqual(ab, bb);
}

function validateAppProxySignature(query, secret) {
const signature = query.signature;
if (!signature || typeof signature !== "string") return false;

const entries = [];
for (const [k, v] of Object.entries(query)) {
if (k === "signature") continue;
if (Array.isArray(v)) entries.push([k, v.join(",")]);
else entries.push([k, String(v)]);
}

const sorted = entries
.map(([k, v]) => `${k}=${v}`)
.sort()
.join("");

const digest = crypto.createHmac("sha256", secret).update(sorted).digest("hex");
return timingSafeEqualHex(signature, digest);
}

/* =========================
SHOPIFY GRAPHQL CALL
========================= */

async function shopifyGraphQL(query, variables) {
const url = `https://${SHOPIFY_SHOP}/admin/api/${SHOPIFY_API_VERSION}/graphql.json`;

const res = await fetch(url, {
method: "POST",
headers: {
"Content-Type": "application/json",
"X-Shopify-Access-Token": SHOPIFY_ADMIN_TOKEN
},
body: JSON.stringify({ query, variables })
});

const json = await res.json();
if (!res.ok) throw new Error(`Shopify HTTP ${res.status}: ${JSON.stringify(json)}`);
if (json.errors?.length) throw new Error(`Shopify GraphQL errors: ${JSON.stringify(json.errors)}`);
return json.data;
}

/* =========================
FORMAT BREAKDOWN (customer-visible)
========================= */

function formatBreakdown(units, totals) {
const lines = [];
lines.push("RightGlaze Bespoke Units – Breakdown (prices inc VAT)");
lines.push(`Units: ${units.length}`);
lines.push("");

units.forEach((u, i) => {
const unitPrice = u._unitPriceIncVat;
const lineTotal = unitPrice * u.qty;
const area = (u.widthMm * u.heightMm) / 1_000_000;

lines.push(`Unit ${i + 1} (Qty ${u.qty})`);
lines.push(`- Outer: ${u.outerGlass}`);
lines.push(`- Inner: ${u.innerGlass}`);
lines.push(`- Cavity: ${u.cavityWidth}`);
lines.push(`- Toughened: Yes`);
lines.push(`- Self-cleaning: ${u.selfCleaning}`);
lines.push(`- Spacer: ${u.spacer}`);
lines.push(`- Size: ${u.widthMm}mm × ${u.heightMm}mm (${area.toFixed(3)} m²)`);
if (u._areaUpgradeApplied) lines.push(`- Note: Auto-upgraded due to area ≥ 2.5m²`);
lines.push(`- Unit price: £${unitPrice.toFixed(2)} (inc VAT)`);
if (u.qty >= 2) lines.push(`- Line total: £${lineTotal.toFixed(2)} (inc VAT)`);
lines.push("");
});

lines.push(`ORDER TOTAL: £${totals.grandTotal.toFixed(2)} (inc VAT)`);
return lines.join("\n");
}

/* =========================
MAIN ENDPOINT (via App Proxy)
Storefront will call:
POST /apps/rightglaze/checkout
which Shopify proxies to:
POST https://YOUR-APP-HOST/proxy/checkout
========================= */

app.post("/proxy/checkout", async (req, res) => {
try {
// 1) Validate app proxy signature
if (!validateAppProxySignature(req.query, SHOPIFY_API_SECRET)) {
return res.status(401).json({ error: "Invalid proxy signature" });
}

// 2) Ensure the shop param matches your store
if (String(req.query.shop || "").toLowerCase() !== SHOPIFY_SHOP.toLowerCase()) {
return res.status(403).json({ error: "Shop mismatch" });
}

// 3) Validate payload
const unitsRaw = req.body?.units;
if (!Array.isArray(unitsRaw) || unitsRaw.length === 0) {
return res.status(400).json({ error: "Missing units[]" });
}

// 4) Normalize + apply rules + calculate
const units = unitsRaw.map(normalizeUnit);

let grandTotal = 0;
for (const u of units) {
const unitPrice = calcUnitPriceIncVat(u);
u._unitPriceIncVat = unitPrice;
grandTotal += unitPrice * u.qty;
}

// block checkout if everything is unpriced
if (grandTotal <= 0) {
return res.status(422).json({
error: "This configuration is currently unpriced (total £0.00). Add more pricing stages before enabling checkout."
});
}

const breakdown = formatBreakdown(units, { grandTotal });

// 5) Create Draft Order with ONE combined custom line item
// Use DraftOrderLineItemInput with title + priceOverride (presentment currency)
// priceOverride is supported for custom pricing in drafts. [oai_citation:1‡Shopify](https://shopify.dev/docs/api/admin-graphql/latest/input-objects/draftorderlineiteminput)
const mutation = `
mutation draftOrderCreate($input: DraftOrderInput!) {
draftOrderCreate(input: $input) {
draftOrder {
id
invoiceUrl
name
}
userErrors {
field
message
}
}
}
`;

const input = {
note: breakdown,
tags: ["rightglaze", "bespoke", "calculator"],
presentmentCurrencyCode: PRESENTMENT_CURRENCY,
lineItems: [
{
title: "Bespoke Double Glazed Units (Custom Order)",
quantity: 1,
requiresShipping: true,
taxable: true,
priceOverride: {
amount: Number(grandTotal.toFixed(2)),
currencyCode: PRESENTMENT_CURRENCY
},
customAttributes: [
{ key: "RightGlaze Calculator", value: "Bespoke DG Units" },
{ key: "Units Count", value: String(units.length) },
{ key: "Grand Total (inc VAT)", value: `£${grandTotal.toFixed(2)}` }
]
}
]
};

const data = await shopifyGraphQL(mutation, { input });
const payload = data?.draftOrderCreate;

if (!payload) throw new Error("No draftOrderCreate payload returned.");

const errors = payload.userErrors || [];
if (errors.length) {
return res.status(400).json({ error: "Draft order error", details: errors });
}

const invoiceUrl = payload.draftOrder?.invoiceUrl;
if (!invoiceUrl) {
return res.status(500).json({ error: "Draft order created but invoiceUrl missing." });
}

// 6) Return invoiceUrl so storefront can redirect straight to payment
return res.json({
invoiceUrl,
grandTotal: Number(grandTotal.toFixed(2))
});
} catch (err) {
console.error(err);
return res.status(500).json({ error: "Server error", message: err.message });
}
});

app.get("/health", (req, res) => res.json({ ok: true }));

app.listen(PORT, () => {
console.log(`RightGlaze draft order app listening on port ${PORT}`);
});